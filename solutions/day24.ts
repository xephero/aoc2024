import { readDayInput } from "../utility";

type GateType = "AND" | "OR" | "XOR";
type WireValue = 0 | 1 | null;

class Wire {
    value: WireValue;

    constructor(value: string) {
        this.value = parseInt(value) as WireValue;
    }
}

type WireList = {[key: string]: Wire};

class Gate {
    type: GateType;
    left: string;
    right: string;
    out: string;
    emitted: boolean = false;

    constructor(gateArray: string[]) {
        this.left = gateArray[0];
        this.type = (gateArray[1] as GateType);
        this.right = gateArray[2];
        this.out = gateArray[4];
    }

    addResult(wires: WireList) {
        if (!(this.left in wires) || !(this.right in wires))
            return;

        const leftVal = wires[this.left].value === 1 ? true : false;
        const rightVal = wires[this.right].value === 1 ? true : false;
        
        if (this.type === "AND")
            wires[this.out] = { value: (leftVal && rightVal) ? 1 : 0 };

        else if (this.type === "OR")
            wires[this.out] = { value: (leftVal || rightVal) ? 1 : 0 };

        else if (this.type === "XOR")
            wires[this.out] = { value: (leftVal !== rightVal) ? 1 : 0 };

        this.emitted = true;
    }
}

function getSum(wires: WireList, gates: Gate[], swaps: string[]) {
    while (!gates.every(g => g.emitted))
        for (const gate of gates)
            gate.addResult(wires);

    let finalValue = 0n;

    for (const [name, wire] of Object.entries(wires)) {
        if (name.startsWith('z') && wire.value === 1)
            finalValue += 2n ** BigInt(name.substring(1));
    }

    return finalValue;
}

function findGate(gates: Gate[], type: GateType, operands: string[], swaps: Set<string>) {
    const result = gates.find(g => g.type === type && operands.includes(g.left) && operands.includes(g.right));

    if (result === undefined)
        return findSwap(gates, type, operands, swaps);

    return result;
}

function findSwap(gates: Gate[], type: GateType, operands: string[], swaps: Set<string>) {
    // One of the operands is not in an appropriate gate

    const leftCandidates = gates.filter(g => g.type === type && [g.left, g.right].includes(operands[0]));
    const rightCandidates = gates.filter(g => g.type === type && [g.left, g.right].includes(operands[1]));

    // Only one of these has a result (i hope). the other term here should swap with the unused operand
    if (leftCandidates.length > 0 && rightCandidates.length > 0)
        throw new Error(`Multiple candidates for ${type} with ${JSON.stringify(operands)}`);

    if (leftCandidates.length > 0) {
        const swapWith = leftCandidates[0].left === operands[0] ? leftCandidates[0].right : leftCandidates[0].left;
        swaps.add(JSON.stringify([operands[1], swapWith].sort()));
        return leftCandidates[0];
    }

    const swapWith = rightCandidates[0].left === operands[1] ? rightCandidates[0].right : rightCandidates[0].left;
    swaps.add(JSON.stringify([operands[0], swapWith].sort()));
    return rightCandidates[0];
}

function findResultSwaps(gates: Gate[], max: number, swaps: Set<string>) {
    for (let i = 1; i < max; i++) {
        // Get the x/y xor result for this bit
        const bitXorGate = gates.find(g => g.type === 'XOR' && [g.left,g.right].includes(`x${i.toString().padStart(2, '0')}`));

        if (bitXorGate === undefined)
            throw new Error(`Couldn't find x/y ${i} gate`);

        // Get the result gate for this bit
        const resultByOrigin = gates.find(g => g.type === 'XOR' && [g.left,g.right].includes(bitXorGate.out));
        const resultByOutput = gates.find(g => g.out === `z${i.toString().padStart(2, '0')}`);

        // If one of these isn't found, then there's some other swap to do besides the result, ignore for now
        if (resultByOrigin === undefined || resultByOutput === undefined)
            continue;

        // If these aren't the same gate, swap their outputs
        if (resultByOrigin.out !== resultByOutput.out) {
            swaps.add(JSON.stringify([resultByOrigin.out, resultByOutput.out].sort()));
            const realOut = resultByOutput.out;
            resultByOutput.out = resultByOrigin.out;
            resultByOrigin.out = realOut;
        }
    }
}

function findAllSwaps(gates: Gate[]) {
    // Result: the z value
    const result: string[] = [];

    // Natural: what this digit would be with no carries in
    const natural: string[] = [''];

    // Carry Gen: the carry digit generated by this spot (i.e., carryGen[0] means z00 generated a carry)
    const carryGen: string[] = [];

    // Carry Over: this bit has a carry from a previous bit and also a natural 1 so we can't use it
    const carryOver: string[] = [''];
    
    // Carry Out: this bit has a carry from somewhere that should continue on
    const carryOut: string[] = [''];

    // Swaps: the swaps we've found so far
    const swaps = new Set<string>();

    // Find out how many bits we're calculating
    const max = gates
        .filter(g => g.out.startsWith('z'))
        .map(g => parseInt(g.out.substring(1)))
        .reduce((a,b) => Math.max(a, b));

    // First pass: any XOR gate without x/y operands should result in a z value
    // Any where this isn't the case, examine the operands to find which bit, and swap z with that
    findResultSwaps(gates, max, swaps);

    for (let i = 0; i < max; i++) {
        const padNum = i.toString().padStart(2, '0');
        const inList = [`x${padNum}`, `y${padNum}`];

        // Every bit has an XOR and AND gate
        const naturalGate = findGate(gates, 'XOR', inList, swaps);
        const carryGenGate = findGate(gates, 'AND', inList, swaps);

        carryGen.push(carryGenGate.out);
        
        // First bit's natural goes into result, and has no other outputs
        if (i === 0) {
            result.push(naturalGate.out);
            continue;
        }

        natural.push(naturalGate.out);

        // Check if this bit has a carry bit that wasn't consumed
        const resultList = [carryOut[i-1], natural[i]];

        // The second bit uses carrygen0 since carryout0 doesn't exist
        if (i === 1) {
            resultList[0] = carryGen[i-1];
        }

        const resultGate = findGate(gates, 'XOR', resultList, swaps);
        const carryOverGate = findGate(gates, 'AND', resultList, swaps);

        if (!resultGate.out.startsWith('z'))
            swaps.add(JSON.stringify([`z${i.toString().padStart(2, '0')}`, resultGate.out].sort()));

        result.push(resultGate.out);
        carryOver.push(carryOverGate.out);

        // Check if this bit has a remaining carry after potentially using one
        const carryOutGate = findGate(gates, 'OR', [carryGen[i], carryOver[i]], swaps);
        carryOut.push(carryOutGate.out);
    }

    // Handle the final gate
    const lastResult = findGate(gates, 'OR', [carryGen[max-1], carryOver[max-1]], swaps);
    result.push(lastResult.out);

    return swaps;
}

export function day24() {
    const input = readDayInput(24);

    const sections = input.split('\n\n');
    const initWires = sections[0].split('\n').map(l => l.split(': '));
    const initGates = sections[1].split('\n').map(l => l.split(' '));

    const wires: WireList = {};
    const gates: Gate[] = [];

    // Initialize wires
    for (const wire of initWires)
        wires[wire[0]] = new Wire(wire[1]);

    // Initialize gates
    for (const gate of initGates)
        gates.push(new Gate(gate));

    let xValue = 0n;
    let yValue = 0n;

    for (const [name, wire] of Object.entries(wires)) {
        if (name.startsWith('x') && wire.value === 1)
            xValue += 2n ** BigInt(name.substring(1));

        if (name.startsWith('y') && wire.value === 1)
            yValue += 2n ** BigInt(name.substring(1));
    }

    // Run every cycle until the gates complete
    while (!gates.every(g => g.emitted))
        for (const gate of gates)
            gate.addResult(wires);

    let zValue = getSum(wires, gates, []);

    console.log(`Part 1: ${zValue}`);

    const swaps = findAllSwaps(gates);

    const swapList = [...swaps].map(s => JSON.parse(s)).flat().sort().join(',');

    console.log(`Part 2: ${swapList}`);

}